#include "Ili9481.h"

/*****************************************************************************\
|* Defines
\*****************************************************************************/

#define LCD_DELAY       0x80

#define LCD_CS(state)   gpio_put(_ctx.spi.pinCS, state)
#define LCD_DATA        gpio_put(_ctx.pinCD, Gpio::HI)
#define LCD_CMD         gpio_put(_ctx.pinCD, Gpio::LO)

#define BUSY_DELAY      10
#define SPI_WRITE(ptr, num)                                                 \
    while (!spi_is_writable(_spi.device()))                                 \
        sleep_us(BUSY_DELAY);                                               \
    spi_write_blocking(_spi.device(), ptr, num)

/*****************************************************************************\
|* Enums
\*****************************************************************************/

enum
    {
    SPI_CMD_SET_COLUMN_ADDRESS          = 0x2A,
    SPI_CMD_SET_ROW_ADDRESS             = 0x2B,
    SPI_CMD_WRITE_MEMORY_START          = 0x2C,
    };

/*****************************************************************************\
|* Statics
\*****************************************************************************/

static Rect _limits = {0, 0, 319, 479};

static const uint8_t _initData[] =
    {
    /*************************************************************************\
    |* 0x00     : NOP
    |* 
    |* This is sent as a dummy byte to make sure the SCK line has the correct
    |* polarity for the *real* 0x01 next...
    \*************************************************************************/
	1, 0x00,

    /*************************************************************************\
    |* 0x01     : Software reset
    |* 
    |* Try to avoid any problems with the SPI engine being confused on the 
    |* display
    \*************************************************************************/
	1, 0x01,
	LCD_DELAY, 240,

    /*************************************************************************\
    |* 0x11     : Exit sleep mode
    |* 
    |* No parameters, must wait 5ms before sending cmd, or 120ms before sleep
    \*************************************************************************/
	1, 0x11,
	LCD_DELAY, 120,

    /*************************************************************************\
    |* 0xD0     : Power setting: (pg 124, 8.2.46)
    |*
    |*  0x7     : Reference voltage - 1.0x Voltage-in
    |*  0x42    : Generate Vgl, config power rails
    |*  0x18    : Internal ref=2.5v
    \*************************************************************************/
	4, 0xD0, 0x07, 0x42, 0x18,

    /*************************************************************************\
    |* 0xD1     : VCOM voltages (pg 116, 8.2.47)
    |* 
    |* 0x00     : Register D1 selected for VCM setting 
    |* 0x07     : VCOMH voltage     = 0.72 * VREG1_OUT
    |* 0x02     : VCOM amplitude    = 0.74 * VREG1_OUT
    \*************************************************************************/
	4, 0xD1, 0x00, 0x07, 0x10,

    /*************************************************************************\
    |* 0xD2     : Power setting for normal mode (pg 118, 8.2.48)
    |* 
    |* 0x01     : Gamma driver = 1.0x, Source driver = 1.0x
    |* 0x02     : fDCDC1 = Fosc, fDCDC2 = Fosc/64
    \*************************************************************************/
	3, 0xD2, 0x01, 0x02,

    /*************************************************************************\
    |* 0xC0     : Panel driving setting (pg 101, 8.2.39)
    |* 
    |* 0x10     : Enable greyscale inversion, scan top left to bottom right
    |* 0x3B     : Number of groups of 8 lines to drive on LCD (0x3b=480 lines)
    |* 0x00     : Starting point in graphics RAM for scanning LCD data in
    |* 0x02     : Inactive areas, output +ve, polarity GND, amp:both, freqs:Y
    |* 0x11     : Inactive areas, interval scan, 3 frames, 50ms
    \*************************************************************************/
	6, 0xC0, 0x10, 0x3B, 0x00, 0x02, 0x11,

    /*************************************************************************\
    |* 0xC5     : Frame Rate and Inversion Control (pg 111, 8.2.43)
    |* 
    |* 0x00     : 125 fps
    \*************************************************************************/
	2, 0xC5, 0x00,

    /*************************************************************************\
    |* 0xC8     : Gamma (pg 113, 8.2.45)
    |* 
    |* params   : See datasheet :)
    \*************************************************************************/
	13, 0xC8, 0x00, 0x32, 0x36, 0x45, 0x06, 0x16, 
              0x37, 0x75, 0x77, 0x54, 0x0C, 0x00,


    /*************************************************************************\
    |* 0x36     : Set_address_mode (pg 79, 8.2.25)
    |* 
    |* 0x0A     : bit 7 = top to bottom order
    |*            bit 6 = left to right order
    |*            bit 5 = normal page/column order
    |*            bit 4 = LCD refresh from top to bottom
    |*            bit 3 = pixels in BGR order 
    |*            bit 2 = n/a 
    |*            bit 1 = flip horozontally 
    |*            bit 0 = no flip vertically
    \*************************************************************************/
	2, 0x36, 0x0A,

    /*************************************************************************\
    |* 0x3A     : Set_pixel_format (pg 87, 8.2.29)
    |* 
    |* 0x55     : bits 6,5,4    = DPI pixel format is 16 bits/pix
    |*          : bits 2,1,0    = DBI pixel format is 16 bits/pix
    \*************************************************************************/
	2, 0x3A, 0x66,

    /*************************************************************************\
    |* 0x29     : Enter invert mode
    |* 
    |* No parameters
    \*************************************************************************/
    1, 0x21,

    /*************************************************************************\
    |* 0xB3     : Frame memory access
    |* 
    |* No parameters
    \*************************************************************************/
    5, 0xB3, 0x00, 0x00, 0x00, 0x01,

    /*************************************************************************\
    |* 0x2A     : Set_column_address (pg 60, 8.2.17)
    |* 
    |* 0x00     : left-most column,  hi-byte = 0
    |* 0x00     : left-most column,  lo-byte = 0        = 0
    |* 0x01     : right-most column, hi-byte = 1
    |* 0x3F     : right-most column, lo-byte = 63       = 319
    \*************************************************************************/
	5, 0x2A, 0x00, 0x00, 0x01, 0x3F,
	LCD_DELAY, 0xff,

    /*************************************************************************\
    |* 0x2B     : Set_page_address (pg 62, 8.2.18) [page = row]
    |* 
    |* 0x00     : upper-most row,  hi-byte = 0
    |* 0x00     : upper-most row,  lo-byte = 0        = 0
    |* 0x01     : lower-most row,  hi-byte = 1
    |* 0xDF     : lower-most row,  lo-byte = 223      = 479
    \*************************************************************************/
	5, 0x2B, 0x00, 0x00, 0x01, 0xDF,

	LCD_DELAY, 120,

    /*************************************************************************\
    |* 0x29     : Turn the display on (pg 59, 8.2.16)
    |* 
    |* No parameters
    \*************************************************************************/
	1, 0x29,

	LCD_DELAY, 25,

    /*************************************************************************\
    |* End of parameters
    \*************************************************************************/
	0
    };

/*****************************************************************************\
|* Constructor
\*****************************************************************************/
Ili9481::Ili9481(void)
        :_clip(_limits)
    {}

/*****************************************************************************\
|* Initialise an ILI9481 display driver using the SPI interface
\*****************************************************************************/
int Ili9481::init(DpyContext *ctx)
    {
    /*************************************************************************\
    |* Make sure the context is valid
    \*************************************************************************/
   if (ctx == nullptr)
        {
        printf(T_ERR "Passed null pointer to Display init()\n");
        return E_INVALID;
        }

    /*************************************************************************\
    |* Copy context and start to use it to configure with
    \*************************************************************************/
    _ctx        = *ctx;
    int errs    = 0;

    /*************************************************************************\
    |* Enable SPI CS and pull it high
    \*************************************************************************/
    if (_ctx.spi.pinCS >= 0)
        {
        gpio_set_dir(_ctx.spi.pinCS, Gpio::OUTPUT);
        gpio_put(_ctx.spi.pinCS, Gpio::HI);
        }
    else
        errs++;


    /*************************************************************************\
    |* Enable the C/D pin as an output if >=0, pull it high
    \*************************************************************************/
    if ((errs==0 ) && (_ctx.pinCD >= 0))
        {
        gpio_set_dir(_ctx.pinCD, Gpio::OUTPUT);
        gpio_pull_up(_ctx.pinCD);
        }

    /*************************************************************************\
    |* Enable the /RST pin as an output if >=0, and trigger a reset
    \*************************************************************************/
    if ((errs==0 ) && (_ctx.pinRST >= 0))
        {
        gpio_set_dir(_ctx.pinRST, Gpio::OUTPUT);
        gpio_pull_up(_ctx.pinRST);

        gpio_put(_ctx.pinRST, Gpio::HI);
        
        sleep_ms(5);
        gpio_put(_ctx.pinRST, Gpio::LO);
        sleep_ms(15);
        gpio_put(_ctx.pinRST, Gpio::HI);
        sleep_ms(150);
        }
    else
        errs ++;

    /*************************************************************************\
    |* Then try to bring up SPI
    \*************************************************************************/
    int ok = 0;
    if (errs == 0)
        {
        int ok = _spi.init(_ctx.spi);
        if (ok != E_OK)
            {
            errs ++;
            printf("Cannot initialise SPI%d device for ILI9481\n", 
                    _ctx.spi.device);
            }
        }

    /*************************************************************************\
    |* Configure the spi interface
    \*************************************************************************/
    spi_set_format(_spi.device(), 8, SPI_CPOL_1, SPI_CPHA_1, SPI_MSB_FIRST);

    /*************************************************************************\
    |* Run the default init sequence
    \*************************************************************************/
	uint8_t  numBytes;
    uint8_t * addr  = (uint8_t *) _initData;

	while ((numBytes=(*addr++))>0)              // end marker == 0
        { 
		if ( numBytes & LCD_DELAY) 
            {
			uint8_t tmp = *addr++;
			sleep_ms(tmp);                      // up to 255 millis
		    } 
        else 
            {
            _writeCommand(*addr ++); 
            while (--numBytes) 
				_writeData(*addr ++); 
		    }
	    }


    return (errs == 0) ? E_OK : -errs;
    }


/*****************************************************************************\
|* Method : Fill a rectangle on the display with a colour
\*****************************************************************************/
void Ili9481::rectFill(Rect r, RGB colour)
    {
    /*************************************************************************\
    |* Clipping : If we're entirely OUB just return
    \*************************************************************************/
    if ((r.x >= _clip.x + _clip.w) || (r.y >= _clip.y + _clip.h))
        return;
    
    /*************************************************************************\
    |* Clipping : If we're off to the left, clip x & adjust w
    \*************************************************************************/
    if (r.x < _clip.x)
        {
        r.w += r.x - _clip.x;
        r.x  = _clip.x;
        }
  
    /*************************************************************************\
    |* Clipping : If we're up above, clip y & adjust h
    \*************************************************************************/
    if (r.y < _clip.y)
        {
        r.h += r.y - _clip.y;
        r.y  = _clip.y;
        }
   
    /*************************************************************************\
    |* Clipping : Make sure we're not too wide or too tall
    \*************************************************************************/
    if ((r.x + r.w) > _clip.w)
        r.w = _clip.w - r.x;
    
    if ((r.y + r.h) > _clip.h)
        r.h = _clip.h - r.y;
   
    /*************************************************************************\
    |* Clipping : If clipping means nothing to draw, return
    \*************************************************************************/
    if ((r.w < 1) || (r.h < 1))
        return;

    /*************************************************************************\
    |* Take CS low
    \*************************************************************************/
    LCD_CS(Gpio::LO);

    /*************************************************************************\
    |* Set the window on-screen that we want to fill to
    \*************************************************************************/
    _setWindow(r);
    _pushBlock(r, colour);
 
    /*************************************************************************\
    |* Take CS high
    \*************************************************************************/
    LCD_CS(Gpio::HI);
   }

/*****************************************************************************\
|* Private Method : Fetch the address mode
\*****************************************************************************/
int Ili9481::fetchAddressMode(void)
    {
    LCD_CS(Gpio::LO);

    /*************************************************************************\
    |* Enter command mode
    \*************************************************************************/
    LCD_CMD;

    uint8_t cmd = 0x0B;
    SPI_WRITE(&cmd, 1); 
    LCD_DATA;
    
    uint8_t result[3] = {0xff,0xff,0x0};
    spi_read_blocking(_spi.device(), 0xfe, result, 2);

    return result[1] & 0xF8;
    }

#pragma mark - Private Methods

/*****************************************************************************\
|* Private Method : write a command over the SPI bus
\*****************************************************************************/
void Ili9481::_writeCommand(uint8_t c, bool handleCS)
    {
    /*************************************************************************\
    |* Take CS low
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::LO);
    
    /*************************************************************************\
    |* Enter command mode
    \*************************************************************************/
    LCD_CMD;

    /*************************************************************************\
    |* Write the SPI command
    \*************************************************************************/
    SPI_WRITE(&c, 1); 
     
    /*************************************************************************\
    |* Return to data mode
    \*************************************************************************/
    LCD_DATA;

    /*************************************************************************\
    |* Take CS high
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::HI);
   }

/*****************************************************************************\
|* Private Method : write a data byte over the SPI bus
\*****************************************************************************/
void Ili9481::_writeData(uint8_t d, bool handleCS)
    {
    /*************************************************************************\
    |* Take CS low
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::LO);
    
    /*************************************************************************\
    |* Should already be in data mode, but...
    \*************************************************************************/
    LCD_DATA;

    /*************************************************************************\
    |* Write the SPI data
    \*************************************************************************/
    SPI_WRITE(&d, 1); 
     
    /*************************************************************************\
    |* This is just a delay, really
    \*************************************************************************/
    LCD_CS(Gpio::LO);

    /*************************************************************************\
    |* Take CS high
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::HI);
    }

/*****************************************************************************\
|* Private Method : set the active window in which to write data.
\*****************************************************************************/
void Ili9481::_setWindow(Rect r, bool handleCS)
    {
    /*************************************************************************\
    |* Take CS low
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::LO);

    /*************************************************************************\
    |* Set the top-left corner
    \*************************************************************************/
   _writeCommand(SPI_CMD_SET_COLUMN_ADDRESS, false);
    _writeData((r.x >> 8) & 0xFF, false);
    _writeData((r.x & 0xFF), false);
    _writeData(((r.x + r.w) >> 8) & 0xFF, false);
    _writeData(((r.x + r.w) & 0xFF), false);
 
    /*************************************************************************\
    |* Set the bottom right corner
    \*************************************************************************/
    _writeCommand(SPI_CMD_SET_ROW_ADDRESS, false);
    _writeData((r.y >> 8) & 0xFF, false);
    _writeData((r.y & 0xFF), false);
    _writeData(((r.y + r.h) >> 8) & 0xFF, false);
    _writeData(((r.y + r.h) & 0xFF), false);
 
    /*************************************************************************\
    |* Take CS high
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::HI);
    }


/*****************************************************************************\
|* Private Method : Push a block of N 16-bit words to the LCD.
|*
|* On entry to this method, CS ought to be already low
\*****************************************************************************/
void Ili9481::_pushBlock(Rect r, RGB rgb, bool handleCS)
    {
    /*************************************************************************\
    |* Take CS low
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::LO);

    
    /*************************************************************************\
    |* Signal that we're about to write pixel data
    \*************************************************************************/
    _writeCommand(SPI_CMD_WRITE_MEMORY_START, false);

    /*************************************************************************\
    |* And do so...
    \*************************************************************************/
    uint8_t buf[3]  = {rgb.r, rgb.g, rgb.b};
    int num         = (r.w + 1) * (r.h + 1);
    for (int i=0; i<num; i++)
        spi_write_blocking(_spi.device(), buf,3);

    /*************************************************************************\
    |* Take CS high
    \*************************************************************************/
    if (handleCS)
        LCD_CS(Gpio::HI);
    }